package com.example.lab02_exploits

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.example.lab02_exploits.SearchFilter
import com.example.lab02_exploits.Notify
import com.google.firebase.firestore.GeoPoint
import com.google.firebase.firestore.SetOptions


class ItemRepository {

    private val itemDB = FirebaseFirestore.getInstance().collection("Items")
    private val notifyDB = FirebaseFirestore.getInstance().collection("Notify")
    private val reviewDB = FirebaseFirestore.getInstance().collection("Review")

    private val mutableData = MutableLiveData<MutableList<Items>>()
    private val notifymutableData = MutableLiveData<MutableList<Notify>>()
    private val reviewMutableData = MutableLiveData<MutableList<Review>>()

    private val listData = mutableListOf<Items>()
    private val notifyListData = mutableListOf<Notify>()
    private val reviewListData = mutableListOf<Review>()

    private lateinit var auth: FirebaseAuth

    fun getItemsData(): LiveData<MutableList<Items>> {
        listData.clear() //Added for duplicated recycler view when backpress
        itemDB.addSnapshotListener{  snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val item = it.toObject(Items::class.java)
                    if (item != null) {
                        listData.add(item)
                    }
                }
                mutableData.value = listData
            }
        }
        return mutableData
    }

    fun getMyFilteredItemsData(auth: FirebaseAuth?, filterList: MutableList<SearchFilter>?): LiveData<MutableList<Items>> {
        Log.d("filterList", "Entered")
        listData.clear() //Added for duplicated recycler view when backpress
        itemDB.addSnapshotListener {  snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val item = it.toObject(Items::class.java)
                    if(auth != null) {
                        val user = auth.currentUser
                        var currentUserId = ""
                        user?.let {
                            currentUserId = user.uid
                        }
                        if (item != null) {
                            if(item.uId == currentUserId) {
                                if(personalizedFilter(item, filterList) == true) {
                                    listData.add(item)
                                }
                            }
                        }
                    } else {
                        if(item?.let { it1 -> personalizedFilter(it1, filterList) } == true) {
                            listData.add(item)
                        }
                    }
                }
                mutableData.value = listData
            }
        }
        return mutableData
    }

    fun getBuyFilteredItemsData(auth: FirebaseAuth?, filterList: MutableList<SearchFilter>?): LiveData<MutableList<Items>> {
        Log.d("filterList", "Entered")
        listData.clear() //Added for duplicated recycler view when backpress
        itemDB.addSnapshotListener {  snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val item = it.toObject(Items::class.java)
                    if(auth != null) {
                        val user = auth.currentUser
                        var currentUserId = ""
                        user?.let {
                            currentUserId = user.uid
                        }
                        if (item != null) {
                            if(item.uId != currentUserId) {
                                if (item.status == "0") { //Added to see if item was already sold
                                    if (personalizedFilter(item, filterList) == true) {
                                        if(item.title != "" && item.category != "Choose Category" && item.price != null && item.location != null) {
                                            listData.add(item)
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if(item?.let { it1 -> personalizedFilter(it1, filterList) } == true) {
                            if(item.title != "" && item.category != "Choose Category" && item.price != null && item.location != null) {
                                listData.add(item)
                            }
                        }
                    }
                }
                mutableData.value = listData
            }
        }
        return mutableData
    }

    fun getInterestedFilteredItemsData(auth: FirebaseAuth?, filterList: MutableList<SearchFilter>?): LiveData<MutableList<Items>> {
        Log.d("filterList", "Entered")
        listData.clear() //Added for duplicated recycler view when backpress
        itemDB.addSnapshotListener {  snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val item = it.toObject(Items::class.java)
                    if(auth != null) {
                        val user = auth.currentUser
                        var currentUserId = ""
                        user?.let {
                            currentUserId = user.uid
                        }
                        var ok = 0
                        for(user in item?.interestUsers!!)
                        {
                            if(auth.currentUser?.uid == user)
                            {
                                ok = 1
                            }
                        }
                        if (item != null && ok == 1) {
                            if(item.uId != currentUserId) {
                                if(personalizedFilter(item, filterList) == true) {
                                    listData.add(item)
                                }
                            }
                        }
                    }
                }
                mutableData.value = listData
            }
        }
        return mutableData
    }

    fun getBoughtListItemsData(auth: FirebaseAuth?, filterList: MutableList<SearchFilter>?): LiveData<MutableList<Items>> {
        Log.d("filterList", "Entered")
        listData.clear() //Added for duplicated recycler view when backpress
        itemDB.addSnapshotListener {  snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val item = it.toObject(Items::class.java)
                    if(auth != null) {
                        val user = auth.currentUser
                        var currentUserId = ""
                        user?.let {
                            currentUserId = user.uid
                        }
                        var ok = 0
                        if(auth.currentUser?.uid == item?.status)
                        {
                            ok = 1
                        }
                        if (item != null && ok == 1) {
                            if(item.uId != currentUserId) {
                                if(personalizedFilter(item, filterList) == true) {
                                    listData.add(item)
                                }
                            }
                        }
                    }
                }
                mutableData.value = listData
            }
        }
        return mutableData
    }

    fun getItem(itemId: String): MutableLiveData<Items> {
        val liveCurrentItem = MutableLiveData<Items>()
        //var currentItem: Items?
        itemDB.document(itemId).addSnapshotListener { snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val currentItem = snapshot.toObject(Items::class.java)
                liveCurrentItem.value = currentItem
                Log.d("Adapter","currentItem $currentItem")
            }

        }
        return liveCurrentItem
    }

    fun getOwner(itemId: String): MutableLiveData<String> {
        val liveCurrentOwner = MutableLiveData<String>()
        //var currentItem: Items?
        itemDB.document(itemId).get().addOnSuccessListener { result ->
            val currentOwner = result.getString("uid")
            liveCurrentOwner.value = currentOwner
            Log.d("Adapter","currentItem $currentOwner")
        }

        return liveCurrentOwner
    }

    fun addInterestedUsers(itemId: String, currentUser: List<String>) {
        // val liveInterestedUsers = MutableLiveData<MutableList<String>>()
        itemDB.document(itemId).update("interestUsers", currentUser )
            .addOnSuccessListener {
                Log.d("ItemRepo", "DocumentSnapshot successfully updated!")
            }
    }

    fun updateLocation (iId: String, location: String, coordinates : GeoPoint) {
        val map = mapOf<String,Any>("location" to location, "geoPoint" to coordinates)
        itemDB.document(iId).set(map, SetOptions.merge())
            .addOnSuccessListener {
                Log.d("userRepo", "Update:success")
            }
            .addOnFailureListener {
                Log.d("userRepo", "Update:failure")
            }
    }

    fun updateBeforeLocation (iId: String, uId : String,title : String, price: Double, category: String, expireDate : String, description : String, photoPath : String){
        val map = mapOf<String,Any>("id" to iId, "uid" to uId, "title" to title, "price" to price, "category" to category, "description" to description, "expireDate" to expireDate, "itemURI" to photoPath)
        itemDB.document(iId).set(map, SetOptions.merge())
            .addOnSuccessListener {
                Log.d("userRepo", "Update:success")
            }
            .addOnFailureListener {
                Log.d("userRepo", "Update:failure")
            }
    }

    fun getLocation (iId: String) : MutableLiveData<GeoPoint> {
        val liveCurrentLoc = MutableLiveData<GeoPoint>()
        itemDB.document(iId).addSnapshotListener { snapshot, e ->
            if(e != null) {
                Log.w("UserRepo", "Listen Failed", e)
            }
            if (snapshot != null) {
                val currentItem = snapshot.getGeoPoint("geoPoint")
                liveCurrentLoc.value = currentItem
            }

        }
        return liveCurrentLoc
    }


    fun buyItem(uid: String, itemId: String) {
        // val liveInterestedUsers = MutableLiveData<MutableList<String>>()
        itemDB.document(itemId).update("status", uid)
            .addOnSuccessListener {
                Log.d("EditItem", "DocumentSnapshot successfully updated!")
            }.addOnFailureListener{
                Log.d("EditItem", "Add:failure")
            }
    }

    fun reviewItemSeller(id: String, uid: String, itemId: String, sellerId: String, rating: String, comment: String) {
        // val liveInterestedUsers = MutableLiveData<MutableList<String>>()
        val reviewObject = Review("", uid, itemId,sellerId, rating, comment)
        reviewDB.document(reviewObject.id).set(reviewObject)
            .addOnSuccessListener {
                reviewListData.add(reviewObject)
                reviewMutableData.value = reviewListData
                Log.d("ReviewQuery", "Add:success")
            }
            .addOnFailureListener{
                Log.d("ReviewQuery", "Add:failure")
            }
    }

    fun getReviewCheck(uid: String, iId: String, sellerId: String): MutableLiveData<Boolean> {
        reviewListData.clear() //Added for duplicated recycler view when backpress
        val reviewed = MutableLiveData<Boolean>()
        var find: Boolean = false
        //reviewMutableData.value = null
        Log.d("ReviewLoopArg", uid)
        Log.d("ReviewLoopArg", iId)
        Log.d("ReviewLoopArg", sellerId)

        reviewDB.addSnapshotListener { snapshot, e ->
            if (e != null) {
                Log.w("ReviewQueryGetSellerMediumReview", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val review = it.toObject(Review::class.java)

                    Log.d("ReviewLoop", review?.userId.toString())
                    Log.d("ReviewLoop", review?.itemId.toString())
                    Log.d("ReviewLoop", review?.sellerId.toString())

                    if (review?.userId == uid && review?.itemId == iId && review?.sellerId == sellerId) {
                        find = true
                    }
                }
                Log.d("ReviewMiddleValueReceivedQuery", find.toString())
                reviewed.value = find
                //Log.d("ReviewFinalValue", reviewed.value.toString())
            }
        }
        Log.d("ReviewQueryFunctionReturnedValue", reviewed.value.toString())
        return reviewed
    }


    fun getReview(uid: String, iId: String, sellerId: String):MutableLiveData<Review>
    {
        reviewListData.clear() //Added for duplicated recycler view when backpress
        val reviewed = MutableLiveData<Review>()


        reviewDB.addSnapshotListener { snapshot, e ->
            if (e != null) {
                Log.w("ReviewQueryGetSellerMediumReview", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val review = it.toObject(Review::class.java)

                    Log.d("ReviewLoop", review?.userId.toString())
                    Log.d("ReviewLoop", review?.itemId.toString())
                    Log.d("ReviewLoop", review?.sellerId.toString())

                    if (review?.userId == uid && review?.itemId == iId && review?.sellerId == sellerId) {
                        reviewed.value = review
                    }
                }
                //Log.d("ReviewFinalValue", reviewed.value.toString())
            }
        }
        Log.d("ReviewQueryFunctionReturnedValue", reviewed.value.toString())
        return reviewed
    }

    fun getSellerMediumReview(sellerId: String): MutableLiveData<Double> {
        reviewListData.clear() //Added for duplicated recycler view when backpress
        val mediumRating = MutableLiveData<Double>()
        var rating = 0.0
        var ratNum = 0.0

        reviewDB.addSnapshotListener{  snapshot, e ->
            if(e != null) {
                Log.w("ReviewQueryGetSellerMediumReview", "Listen Failed", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val review = it.toObject(Review::class.java)
                    if (review != null && review.sellerId == sellerId) {
                        reviewListData.add(review)
                    }
                }
                for(rev in reviewListData)
                {
                    ratNum = ratNum + 1
                    rating = (rating + rev.rating.toDouble())
                    Log.w("ratingQuery", ratNum.toString())
                    Log.d("ratingQuery", rating.toString())
                }
                mediumRating.value = rating/ratNum
                reviewListData.clear()
                rating = 0.0
                ratNum = 0.0
            }
        }
        return mediumRating
    }

    //Here i get all notifications i need and update the status of already sent notifications
    fun fetchNotifications(auth: FirebaseAuth?): LiveData<MutableList<Notify>> {
        Log.d("Notification", "FetchNotification")
        notifyListData.clear() //Added for duplicated recycler view when backpress
        notifyDB.addSnapshotListener {  snapshot, e ->
            if(e != null) {
                Log.w("Notificaiton", "FetchNotification", e)
            }
            if (snapshot != null) {
                val documents = snapshot.documents
                documents.forEach {
                    val notify = it.toObject(Notify::class.java)
                    if(auth != null) {
                        val user = auth.currentUser
                        var currentUserId = ""
                        user?.let {
                            currentUserId = user.uid
                        }
                        if (notify != null) {
                            if(notify.userId == currentUserId) {
                                if(notify.notified == false) {
                                    notifyListData.add(notify)
                                    notify.notified = true
                                    updateNotification(notify.identifier, notify)
                                    Log.w("Notificaiton", "UpdateNotification", e)
                                }
                            }
                        }
                    }
                }
                notifymutableData.value = notifyListData
            }
        }
        return notifymutableData
    }


    fun updateNotification(identifier: String, notifyObject: Notify)
    {
        notifyDB.document(identifier).set(notifyObject)
            .addOnSuccessListener {
                Log.d("NotifyRepo", "Update:success")
            }
            .addOnFailureListener {
                Log.d("NotifyRepo", "Update:failure")
            }
    }

    fun addItem (itemId: String, itemObject: Items) {
        itemDB.document(itemId).set(itemObject)
                .addOnSuccessListener {
                listData.add(itemObject)
                mutableData.value = listData
                Log.d("ItemRepo", "Add:success")

                }
            .addOnFailureListener{
                Log.d("ItemRepo", "Add:failure")
            }
    }

    fun updateItem (itemId : String, itemObject: Items) {
        itemDB.document(itemId).set(itemObject)
            .addOnSuccessListener {
                Log.d("ItemRepo", "Update:success")
            }
            .addOnFailureListener {
                Log.d("ItemRepo", "Update:failure")
            }
    }

    fun deleteItem (itemId : String) {
        itemDB.document(itemId).delete()
            .addOnSuccessListener {
                Log.d("userRepo", "Update:success")
            }
            .addOnFailureListener {
                Log.d("userRepo", "Update:failure")
            }
    }

    private fun personalizedFilter(item: Items, filterList: MutableList<SearchFilter>?): Boolean? {
        var passed = true

        if(filterList != null)
        {
            loop@ for(filter in filterList)
            {
                when (filter.type) {
                    0 -> {
                        //Title filter
                        if(item.title == "" || item.title == null)
                        {
                            passed = false
                            break@loop
                        }
                        if (item.title.toString().contains(filter.data, ignoreCase = true)) {
                            Log.d("filterList", "passed")
                        } else {
                            passed = false
                            Log.d("filterList", "rejected")
                            break@loop
                        }
                    }
                    1 -> {
                        if(item.description == "" || item.description == null)
                        {
                            passed = false
                            break@loop
                        }
                        //Description filter
                        if (item.description.toString().contains(filter.data, ignoreCase = true)) {
                        } else {
                            passed = false
                            Log.d("filterList", "rejected")
                            break@loop
                        }
                    }
                    2 -> {
                        if(item.price == null || item.price.toString() == null)
                        {
                            passed = false
                            break@loop
                        }
                        //Price filter
                        var minPrice = filter.data.split('-')[0]
                        var maxPrice = filter.data.split('-')[1]
                        if(minPrice == "")
                        {
                            minPrice = "0"
                        }
                        if(maxPrice == "")
                        {
                            maxPrice = "100000000000000"
                        }
                        if (minPrice.toDouble() <= item.price!! && maxPrice.toDouble() >= item.price!!) {
                        } else {
                            passed = false
                            Log.d("filterList", "rejected")
                            break@loop
                        }
                    }
                    3 -> {
                        //Category filter
                        if(item.category == "" || item.expireDate == null || item.category == "Choose Category")
                        {
                            passed = false
                            break@loop
                        }
                        if (item.category.toString().contains(filter.data, ignoreCase = true)) {
                        } else {
                            passed = false
                            Log.d("filterList", "rejected")
                            break@loop
                        }
                    }
                    4 -> {
                        //Location filter
                        if(item.location == "" || item.location == null)
                        {
                            passed = false
                            break@loop
                        }
                        if (item.location.toString().contains(filter.data, ignoreCase = true)) {
                        } else {
                            passed = false
                            Log.d("filterList", "rejected")
                            break@loop
                        }
                    }
                    5 -> {
                        //ExpireDate filter
                        Log.d("expire", item.expireDate.toString())
                        Log.d("expireFilter", filter.data.toString())
                        if(item.expireDate == "" || item.expireDate == null)
                        {
                            passed = false
                            break@loop
                        }
                        val filterday = filter.data.split('/')[0]
                        val filtermonth = filter.data.split('/')[1]
                        val filteryear = filter.data.split('/')[2]
                        val itemday = item.expireDate!!.split('/')[0]
                        val itemmonth = item.expireDate!!.split('/')[1]
                        val itemyear = item.expireDate!!.split('/')[2]

                        var ok = true
                        if(itemyear.toDouble() < filteryear.toDouble()){
                            passed = false
                            break@loop
                        }
                        if(itemyear.toDouble() == filteryear.toDouble())
                        {
                            if(itemmonth.toDouble() < filtermonth.toDouble())
                            {
                                passed = false
                                break@loop
                            }
                            if(itemmonth.toDouble() == filtermonth.toDouble())
                            {
                                if(itemday.toDouble() < filterday.toDouble())
                                {
                                    passed = false
                                    break@loop
                                }
                            }
                        }
                    }
                }
            }
        }
        return passed
    }
}