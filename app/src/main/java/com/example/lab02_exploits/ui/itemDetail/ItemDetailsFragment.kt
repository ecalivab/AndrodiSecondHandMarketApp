package com.example.lab02_exploits.ui.itemDetail

import androidx.lifecycle.ViewModelProviders
import android.os.Bundle
import android.util.Log
import android.view.*
import android.widget.Button
import android.widget.PopupMenu
import android.widget.TextView
import android.widget.Toast
import androidx.core.view.get
import androidx.fragment.app.Fragment
import androidx.lifecycle.Observer
import androidx.navigation.fragment.findNavController
import com.android.volley.toolbox.JsonObjectRequest
import com.bumptech.glide.Glide
import com.example.lab02_exploits.R
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.OnMapReadyCallback
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.MarkerOptions
import com.google.android.material.snackbar.Snackbar
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.GeoPoint
import com.google.firebase.messaging.FirebaseMessaging
import kotlinx.android.synthetic.main.fragment_item_details.*
import kotlinx.android.synthetic.main.fragment_item_details.location
import org.json.JSONException
import org.json.JSONObject
import java.lang.StringBuilder
import com.android.volley.Response
import com.android.volley.toolbox.Volley

class ItemDetailsFragment : Fragment(), OnMapReadyCallback {

    var photoPath : String = ""
    var itemId = "0"
    private var itemName = ""
    private lateinit var auth: FirebaseAuth
    private var currentUser : String? = null
    private var itemOwner : String? = null
    private var interestUsersList : MutableList<String> = ArrayList()
    private var interestedUserNameMap  : HashMap<String,String> = HashMap()

    private var geoItem: GeoPoint? = null

    private lateinit var mMap : GoogleMap
    private var mapReady = false

    companion object {
        private const val FCM_API = "https://fcm.googleapis.com/fcm/send"
        private const val serverKey = "key= ADD KEY"
        private const val contentType = "application/json"
        fun newInstance() =
            ItemDetailsFragment()
    }

    private lateinit var viewModel: ItemDetailsViewModel

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        setHasOptionsMenu(true)
        return inflater.inflate(R.layout.fragment_item_details, container, false)
    }


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        itemId = arguments?.getString("adapter_id", "0") ?: "0"
        itemOwner = arguments?.getString("adapter_uid", "0") ?: "0"
        interestUsersList = arguments?.getStringArrayList("adapter_userList") ?: mutableListOf()
        itemName =  arguments?.getString("adapter_title","Title") ?: ""
        Log.d("ItemDetail", "interestUsers: $interestUsersList")

        Log.d("position", "OnViewCreated")
        mapItem.onCreate(savedInstanceState)
        mapItem.onResume()
        mapItem.getMapAsync (this)


        /*
        price.text = arguments?.getString("adapter_price", "00.00")
        category.text = arguments?.getString("adapter_category","Category")
        expirydate.text =  arguments?.getString("adapter_expireDate", "1/1/1800")

        location.text =  arguments?.getString("adapter_location","Location")
        description.text =  arguments?.getString("adapter_description","Description")
        photoPath = arguments?.getString("adapter_itemURI","") ?: ""
        Log.d("KKA", "PhotoTaken ItemDetails: $photoPath")
        if (!photoPath.isNullOrBlank()) {
            BitmapFactory.decodeFile(photoPath)?.also { imageBitmap ->
                itemphoto.setImageBitmap(imageBitmap)
            }
        }*/
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewModel = ViewModelProviders.of(this).get(ItemDetailsViewModel::class.java)
        Log.d("ItemDetails", "OnActivityResult")
        auth = FirebaseAuth.getInstance()
        currentUser = auth.currentUser?.uid

        observeCurrentItem (itemId)
        observeNames (interestUsersList)

        like.setOnClickListener{
            if (currentUser != itemOwner ) {
                if (interestUsersList.contains(currentUser)) {
                    Toast.makeText(requireContext(), "You Already Show Interesd in this Item", Toast.LENGTH_LONG).show()
                } else {
                    currentUser?.let { it1 -> interestUsersList.add(it1) }
                    Log.d("ItemList", "like: $interestUsersList")
                    viewModel.addInterestUsers(itemId, interestUsersList)
                    FirebaseMessaging.getInstance().subscribeToTopic(itemId) //subscribe if the Like the item
                    sendNotificationToSubscribers("Show Interest", "A user show interest in the item")
                    //Send Buyer a notification
                    Toast.makeText(requireContext(), "Add this Item to your Interest", Toast.LENGTH_LONG).show()
                }

            } else {
                showPopupNames(it, interestedUserNameMap)
            }
        }


        contact.setOnClickListener {
            val bundle = Bundle()
            bundle.putString("itemInterestedUser", itemOwner) // Re-utilize like button to redirect to seller profile
            findNavController().navigate(R.id.action_nav_itemDetails_to_nav_showProfile,bundle)
        }

        val selButton : Button? = activity?.findViewById(R.id.buy)
        selButton?.setOnClickListener{
            Log.d("EditItem", "EntraSelButton")
            sendNotificationToSubscribers("Item: ${title.text} Sold", "A user has bought this Item")
            viewModel.buyItem(auth.currentUser!!.uid, itemId)
        }

        if (currentUser == itemOwner) { // Hide the item menu if the current is not the owner
            buy.visibility = View.GONE
            contact.visibility = View.GONE

        }
        if (currentUser.isNullOrEmpty()) {
            buy.visibility = View.GONE
            like.visibility = View.GONE
        }


        location.setOnClickListener {
            val bundle = Bundle()
            geoItem?.latitude?.let { it1 -> bundle.putDouble("geoItemLatitude", it1) }
            geoItem?.longitude?.let { it1 -> bundle.putDouble("geoItemLongitude", it1) }
            findNavController().navigate(R.id.action_nav_itemDetails_to_nav_mapDirections, bundle)
        }
    }

    //unsubscribeFromTopic
    private fun sendNotificationToSubscribers(titleNotification : String, message : String) {

        val notification = JSONObject()
        val notificationBody = JSONObject()

        try {
            notificationBody.put("title", titleNotification)
            notificationBody.put("text", "$message: ${title.text}")   //Enter your notification message
            notification.put("to", "/topics/$itemId")
            notification.put("notification", notificationBody)
            Log.e("TAG", "try")
        } catch (e: JSONException) {
            Log.e("TAG", "onCreate: " + e.message)
        }
        Log.d("TAG", "$notification")
        sendNotification(notification)
    }

    private fun sendNotification(notification: JSONObject) {
        Log.e("TAG", "sendNotification")
        val jsonObjectRequest = object : JsonObjectRequest(FCM_API, notification,
            Response.Listener<JSONObject> { response ->
                Log.i("TAG", "onResponse: $response")
            },
            Response.ErrorListener {
                Toast.makeText(requireContext(), "Request error", Toast.LENGTH_LONG).show()
                Log.i("TAG", "onErrorResponse: Didn't work")
            }) {

            override fun getHeaders(): Map<String, String> {
                val params = HashMap<String, String>()
                params["Authorization"] = serverKey
                params["Content-Type"] = contentType
                return params
            }
        }
        val requestQueue = Volley.newRequestQueue(requireContext())
        requestQueue.add(jsonObjectRequest)
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.edit_menu, menu)
    }

    override fun onPrepareOptionsMenu(menu: Menu) {
        super.onPrepareOptionsMenu(menu)

        val item = menu.findItem(R.id.editar)

        if (currentUser != itemOwner ) { // Hide the item menu if the current is not the owner
          item.isVisible = false
        }

    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.editar -> {
                editItem();
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    private fun observeCurrentItem (iId : String) {
        viewModel.fetchItem(iId).observe(viewLifecycleOwner, Observer{
            price.text = it.price.toString()
            title.text = it.title
            category.text = it.category
            location.text = it.location
            expirydate.text= it.expireDate
            description.text = it.description
            if(it.status == "1" || it.status != "0") {
                buy.visibility = View.GONE
            }

            geoItem = it?.geoPoint
            updateMap()

            photoPath = it.itemURI.toString()
            if (!it.itemURI.isNullOrEmpty()) {
                Glide.with(requireContext())
                    .load(it.itemURI)
                    .into(itemphoto)
            }
        })
    }

    private fun observeNames(list : MutableList<String>) {
        if (list.isNotEmpty()) {
            for (i in list) {
                viewModel.getUserName(i).observe(viewLifecycleOwner, Observer {
                    interestedUserNameMap[it] = i
                })
            }
        }
    }


    private fun showPopupNames(view: View?, userNameMap: HashMap<String,String>) {
        var popup: PopupMenu? = null;
        popup = PopupMenu(requireContext(), view)
        for ((key, value) in userNameMap){
            popup.menu.add(key)
        }

        popup.setOnMenuItemClickListener(PopupMenu.OnMenuItemClickListener { item: MenuItem? ->
            val itm = item.toString()
            Log.d("itemDetail", "popUp: ${userNameMap[itm]}")
            val bundle = Bundle()
            bundle.putString("itemInterestedUser", userNameMap[itm])
            findNavController().navigate(R.id.action_nav_itemDetails_to_nav_showProfile,bundle)

            true
        })
        popup.show()
    }
    //End handle subcategory menu

    private fun editItem() {
        val bundle = Bundle()
        bundle.putString("adapter_id", itemId)
        bundle.putString("adapter_title", title.text.toString())
        bundle.putString("adapter_description", description.text.toString())
        bundle.putString("adapter_price", price.text.toString())
        bundle.putString("adapter_category", category.text.toString())
        bundle.putString("adapter_location", location.text.toString())
        bundle.putString("adapter_expireDate", expirydate.text.toString())
        bundle.putString("adapter_itemURI", photoPath)
        bundle.putStringArrayList("adapter_userList", interestUsersList as ArrayList<String>)
        findNavController().navigate(R.id.action_nav_itemDetails_to_nav_itemEdit,bundle)
    }

    private fun updateMap() {
        Log.d("position", "Entre updateMap")
        Log.d("position", "$mapReady")
        Log.d("position", "${geoItem}")
        if (mapReady && geoItem != null) {
            Log.d("position", "MapMarker")
            mMap.addMarker(MarkerOptions().position(LatLng(geoItem?.latitude!!, geoItem?.longitude!!)))
            mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(geoItem?.latitude!!, geoItem?.longitude!!), 12F));
        }
    }

    override fun onMapReady(googleMap : GoogleMap?) {
        Log.d("position", "Entre a MapReady")
        googleMap?.let { map ->
            mMap = map
            mapReady = true
            map.uiSettings.setAllGesturesEnabled(false)
            updateMap()
            map.setOnMapClickListener {
                val bundle = Bundle()
                geoItem?.latitude?.let { it1 -> bundle.putDouble("geoItemLatitude", it1) }
                geoItem?.longitude?.let { it1 -> bundle.putDouble("geoItemLongitude", it1) }
                findNavController().navigate(R.id.action_nav_itemDetails_to_nav_mapDirections, bundle)
            }
        }
    }


    private fun showInterestedOwners(view : View, interested : List<String>) {
        var stringBuild = StringBuilder()
        if (interested.isNotEmpty()) {
            for (i in interested) {
                stringBuild = stringBuild.append(i)
                stringBuild = stringBuild.append("\n")
            }
        } else {
            stringBuild = stringBuild.append("No User are Interested")
        }

        val snackbar = Snackbar.make(view, stringBuild, Snackbar.LENGTH_INDEFINITE)
        snackbar.setAction("Close", View.OnClickListener {
            snackbar.dismiss()
        })
        snackbar.view.findViewById<TextView>(R.id.snackbar_text).maxLines = 10
        snackbar.show()
    }

}
