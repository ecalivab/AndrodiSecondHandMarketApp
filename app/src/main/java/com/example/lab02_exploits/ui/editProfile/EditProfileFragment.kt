package com.example.lab02_exploits.ui.editProfile

import android.Manifest
import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.graphics.drawable.BitmapDrawable
import android.media.ExifInterface
import android.net.Uri
import android.os.Build
import androidx.lifecycle.ViewModelProviders
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.text.TextUtils
import android.util.Log
import android.view.*
import androidx.fragment.app.Fragment
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.addCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.FileProvider
import androidx.navigation.fragment.findNavController
import com.bumptech.glide.Glide
import com.example.lab02_exploits.R
import com.example.lab02_exploits.Users
import com.google.android.gms.maps.model.MarkerOptions
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.gson.Gson
import kotlinx.android.synthetic.main.fragment_edit_profile.*
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.OutputStream
import java.text.SimpleDateFormat
import java.util.*
import androidx.lifecycle.Observer
import com.google.firebase.firestore.GeoPoint
import kotlinx.android.synthetic.main.fragment_edit_details.*


class EditProfileFragment : Fragment() {

    private var rot = 0
    private var  photoTakenPath : String = "";
    private lateinit var auth: FirebaseAuth
    private var userId :String? = null
    private var photoURI: Uri? = null
    private var marker : MarkerOptions = MarkerOptions()
    private var location = ""
    private var token = ""
    private var geoUser : GeoPoint? = null

    companion object {
        fun newInstance() =
            EditProfileFragment()
        //image pick code
        private val IMAGE_PICK_CODE = 1000;
        //Permission code
        private val PERMISSION_CODE = 1001;
    }

    private lateinit var viewModel: EditProfileViewModel

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        setHasOptionsMenu(true)
        return inflater.inflate(R.layout.fragment_edit_profile, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        activity?.window?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); //WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE
        activity?.window?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN)


        marker = arguments?.getParcelable<MarkerOptions>("user_loc") ?: MarkerOptions()

        /*
        location = arguments?.getString("user_addr") ?: ""

        Log.d("positionEdit", "City $location")
        locationEdit?.text = location

        Log.d("positionEdit", "Lat ${marker.position?.latitude}")
        Log.d("positionEdit", "Long ${marker.position?.longitude}")
        */


        requireActivity().onBackPressedDispatcher.addCallback(this) {
            Toast.makeText(requireContext(), "Please Save Before Going Back", Toast.LENGTH_LONG).show()
            //findNavController().navigate(R.id.action_nav_editProfile_to_nav_showProfile)
        }

    }

    override fun onSaveInstanceState(outState: Bundle) {
        if(photoTakenPath != "") {
            outState.putString("image", photoTakenPath)
        }
        super.onSaveInstanceState(outState)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewModel = ViewModelProviders.of(this).get(EditProfileViewModel::class.java)
        val imgMenu : ImageButton? = activity?.findViewById(R.id.photoEdit);
        if (imgMenu != null) {
            registerForContextMenu(imgMenu)
        }


        auth = FirebaseAuth.getInstance()
        Log.d("ShowProfile", "Auth: $auth")
        userId = auth.currentUser?.uid

        if(auth.currentUser == null){
            nameEdit.visibility = View.VISIBLE
            nicknameEdit.visibility = View.VISIBLE
            locationEdit.visibility = View.VISIBLE
            emailEdit.visibility = View.VISIBLE
            passwordEdit.visibility = View.VISIBLE
            SavePassword.visibility = View.GONE
        }
        else{
            nameEdit.visibility = View.VISIBLE
            nicknameEdit.visibility = View.VISIBLE
            locationEdit.visibility = View.VISIBLE
            emailEdit.visibility = View.GONE
            passwordEdit.visibility = View.GONE
            SavePassword.visibility = View.GONE
        }

        //Buttons!!
        changeAccount.setOnClickListener {
            UpdateAccountlayout()
        }

        SavePassword.setOnClickListener{
            auth.currentUser?.let { it1 -> updateAccount(it1) }
        }

        locationEdit.setOnClickListener {
           // val intent = Intent(context, MapsActivity::class.java)
            //startActivity(intent)
            if (ActivityCompat.checkSelfPermission(requireContext(), Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                    requireContext(), Manifest.permission.ACCESS_COARSE_LOCATION ) != PackageManager.PERMISSION_GRANTED) {
                val permissions = arrayOf(Manifest.permission.ACCESS_FINE_LOCATION)
                requestPermissions(permissions, 1520);

            } else {
                userId?.let { it1 -> viewModel.updateUserBeforeMaps(it1, nameEdit?.text.toString(), nicknameEdit?.text.toString(), photoTakenPath) }
                findNavController().navigate(R.id.action_nav_editProfile_to_nav_maps)
            }
        }

        observeToken()
        observeUser()

    }


    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_TAKE_PHOTO && resultCode == AppCompatActivity.RESULT_OK) {
            //val imageURI = data?.extras?.get("data")
            //BitmapFactory.decodeFile(currentPhotoPath)?.also { imageBitmap ->
            // photoEdit.setImageBitmap(imageBitmap)
            //}
            Log.d("EditProfile", "photoURI: $photoURI")
            //rotateImage(photoTakenPath.toString(), photoEdit , setReducedImageSize(photoTakenPath, photoEdit));
            Glide.with(requireContext())
                .load(photoTakenPath)
                .into(photoEdit)

        }

        if (resultCode == Activity.RESULT_OK && requestCode == IMAGE_PICK_CODE) {
            photoEdit.setImageURI(data?.data)
            photoURI = data?.data!!
            val bitmap = (photoEdit.drawable as BitmapDrawable).bitmap
            savePhotoInternalStorage(bitmap, true)
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.save_menu, menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {

        return when (item.itemId) {
            R.id.saveM -> {
               // if (!photoTakenPath.isNullOrBlank()) {
                  //  savePhotoInternalStorage(BitmapFactory.decodeFile(photoTakenPath))
              //  }

                Log.d("EditP", "SAVE")
                if(TextUtils.isEmpty(nameEdit.text)){
                    nameEdit.error = "Name is required"
                    return false
                } else if(TextUtils.isEmpty(nicknameEdit.text)){
                    nicknameEdit.error = "Nickname is required"
                    return false
                }else if(TextUtils.isEmpty(locationEdit.text)) {
                    locationEdit.text = ("Location is required")
                    return false
                }
                Log.d("EditP", "END OF SAVE")
                //savePreferences();
                returnValuesNav();
                true
            }
            android.R.id.home -> {
                if(TextUtils.isEmpty(nameEdit.text)){
                    nameEdit.error = "Name is required"
                    return true
                } else if(TextUtils.isEmpty(nicknameEdit.text)){
                    nicknameEdit.error = "Nickname is required"
                    return true
                }else if(TextUtils.isEmpty(locationEdit.text)) {
                    locationEdit.text = ("Location is required")
                    return true
                }
                Log.d("EditP", "END OF SAVE")
                //savePreferences();
                //returnValuesNav();
                Toast.makeText(requireContext(), "Please Save Before Going Back", Toast.LENGTH_LONG).show()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    override fun onCreateContextMenu(menu: ContextMenu, v: View, menuInfo: ContextMenu.ContextMenuInfo?) {
        super.onCreateContextMenu(menu, v, menuInfo)
        menu.setHeaderTitle("Choose an Option")
        val inflater : MenuInflater? = activity?.menuInflater
        inflater?.inflate(R.menu.photo_menu, menu)
    }


    override fun onContextItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.gallery -> {
                pickImageFromGallery();
                Toast.makeText(activity?.applicationContext, "Gallery", Toast.LENGTH_SHORT).show()
                true
            }
            R.id.camera -> {
                dispatchTakePictureIntent();
                Toast.makeText(activity?.applicationContext, "Camera", Toast.LENGTH_SHORT).show()
                true
            }
            R.id.rotate -> {
                if(photoTakenPath.isEmpty()) {
                    Toast.makeText(requireContext(), "There is not an image", Toast.LENGTH_SHORT).show()
                    return true
                }
                if(photoTakenPath?.startsWith("http")!!){
                    val bitmap = (photoEdit.drawable as BitmapDrawable).bitmap
                    savePhotoInternalStorage(bitmap, true)
                }
                Log.d("asd", "rotate: $photoTakenPath")
                rotate(photoEdit, setReducedImageSize(photoTakenPath, photoEdit))
                Toast.makeText(activity?.applicationContext, "Rotate", Toast.LENGTH_SHORT).show()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    //photoTakenPath is hardcoded maybe is better to change as a function parameter (future work)
    private fun savePhotoInternalStorage(photo: Bitmap, flag: Boolean = false) :Uri {
        val dir= activity?.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
        Log.d("KKK", "FLAG $flag")

        val file = if (flag) {
            File(dir, "${UUID.randomUUID()}.jpg")
        } else {
            File(photoTakenPath)
        }

        try {
            // Get the file output stream
            val stream: OutputStream = FileOutputStream(file)
            // Compress bitmap
            photo.compress(Bitmap.CompressFormat.JPEG, 100, stream)
            // Flush the stream
            stream.flush()
            // Close stream
            stream.close()
        } catch (e: IOException) { // Catch the exception
            e.printStackTrace()
        }
        photoTakenPath=file.absolutePath
        return Uri.fromFile(file)
        //return  file.absolutePath
    }

    private fun observeUser(){
        userId?.let { it ->
            viewModel.getUser(it).observe(viewLifecycleOwner, Observer {
                nameEdit.setText(it?.name)
                nicknameEdit.setText(it?.nickname)
                locationEdit.text = (it?.location)
                emailEdit.setText(it?.email)
                photoTakenPath = (it?.photoPath.toString())

                geoUser = it?.geoPoint

                if (!photoTakenPath.isBlank()) {
                    Glide.with(requireContext())
                        .load(photoTakenPath)
                        .into(photoEdit)
                }
            })
        }
    }

    private fun observeToken(){
        viewModel.regToken().observe(viewLifecycleOwner, Observer {
            token = it
        })
    }

    private fun returnValuesNav() {
       /* val bundle = Bundle()
        bundle.putString("lab02_fullName", nameEdit.text.toString())
        bundle.putString("lab02_nickname", nicknameEdit.text.toString())
        bundle.putString("lab02_email", emailEdit.text.toString())
        bundle.putString("lab02_location", locationEdit.text.toString())
        bundle.putString("lab02_imagepath", photoTakenPath)
        Log.d("KKK","ReturnNavValues: $bundle" )*/
        Log.d("EditP", "photoTakenPath: $photoTakenPath")
        Log.d("EditP", "Location: $location")
        //val geoUser = GeoPoint(marker.position.latitude, marker.position.longitude)
        val obj = Users(userId, nameEdit.text.toString(), nicknameEdit.text.toString(),auth.currentUser?.email.toString(),locationEdit.text.toString(), photoTakenPath, geoUser,token)
        userId?.let { viewModel.updateUser(it, obj, photoURI, findNavController())}
        Log.d("EditP", "ReturnValues")
        //findNavController().navigate(R.id.action_nav_editProfile_to_nav_showProfile)
    }


    // CAMERA FEATURE
    /*
    val REQUEST_IMAGE_CAPTURE = 1

    private fun dispatchTakePictureIntent() {
        Intent(MediaStore.ACTION_IMAGE_CAPTURE).also { takePictureIntent ->
            takePictureIntent.resolveActivity(packageManager)?.also {
                startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE)
            }
        }
    }
     */

    ///GALLERY
    private fun pickImageFromGallery (){
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if(activity?.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED) {
                val permissions = arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE);
                //show popup to request runtime permission
                requestPermissions(permissions, PERMISSION_CODE);

            } else {
                val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
                intent.type = "image/*"
                startActivityForResult(intent, IMAGE_PICK_CODE)
            }
        }
        else {
            //system OS is < Marshmallow
            val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
            intent.type = "image/*"
            startActivityForResult(intent, IMAGE_PICK_CODE)
        }
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        when(requestCode){
            PERMISSION_CODE -> {
                if (grantResults.isNotEmpty() && grantResults[0] ==
                    PackageManager.PERMISSION_GRANTED){
                    //permission from popup granted
                    pickImageFromGallery()
                }
                else{
                    //permission from popup denied
                    Toast.makeText(activity, "Permission denied", Toast.LENGTH_SHORT).show()
                }
            }

            1520 -> {
                if (grantResults.isNotEmpty() && grantResults[0] ==
                    PackageManager.PERMISSION_GRANTED){
                    //permission from popup granted
                    findNavController().navigate(R.id.action_nav_editProfile_to_nav_maps)
                }
                else{
                    //permission from popup denied
                    Toast.makeText(activity, "Permission denied", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    //CAMERA
    lateinit var currentPhotoPath: String

    @SuppressLint("SimpleDateFormat")
    @Throws(IOException::class)
    private fun createImageFile(): File {
        // Create an image file name
        val timeStamp: String = SimpleDateFormat("yyyyMMdd_HHmmss").format(Date())
        val storageDir: File? = activity?.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
        return File.createTempFile("JPEG_${timeStamp}_", ".jpg", storageDir).apply {
            // Save a file: path for use with ACTION_VIEW intents
            currentPhotoPath = absolutePath
            photoTakenPath = currentPhotoPath
        }
    }

    val REQUEST_TAKE_PHOTO = 1

    private fun dispatchTakePictureIntent() {
        Intent(MediaStore.ACTION_IMAGE_CAPTURE).also { takePictureIntent ->
            // Ensure that there's a camera activity to handle the intent
            activity?.packageManager?.let { it ->
                takePictureIntent.resolveActivity(it)?.also {
                    // Create the File where the photo should go
                    val photoFile: File? = try {
                        createImageFile()
                    } catch (ex: IOException) {
                        // Error occurred while creating the File
                        null
                    }
                    // Continue only if the File was successfully created
                    photoFile?.also {
                        photoURI = FileProvider.getUriForFile(requireContext(), "com.example.android.fileprovider", it)
                        takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI)
                        startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO)
                    }
                }
            }
        }
    }
    //////////////

    //ROTATE IMAGE
    private fun setReducedImageSize(currentPath : String?, imgView : ImageView) : Bitmap {
        val targetImageViewWidth: Int = photoEdit.width
        val targetImageViewHeight: Int = photoEdit.height

        val bmOptions = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }

        BitmapFactory.decodeFile(currentPath, bmOptions)
        val cameraImageWidth =  bmOptions.outWidth
        val cameraImageHeight = bmOptions.outHeight

        val scaleFactor = Math.min(cameraImageWidth/targetImageViewWidth, cameraImageHeight/targetImageViewHeight);
        bmOptions.inSampleSize = scaleFactor;
        bmOptions.inJustDecodeBounds = false;

        //var photoReducedSizeBitmp : Bitmap = BitmapFactory.decodeFile(currentPath,bmOptions);
        //imgView.setImageBitmap(photoReducedSizeBitmp);
        return BitmapFactory.decodeFile(currentPath,bmOptions);
    }

    private fun rotate(imgView: ImageView, bitmap : Bitmap) {
        Log.d("asd" , "img rotate")
        val matrix = Matrix()
        rot += 90
        if(rot >= 360)
        {
            rot = 0
        }
        matrix.setRotate(rot.toFloat())
        val rotatedBitmap : Bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
        //photoURI = FileProvider.getUriForFile(requireContext(), "com.example.android.fileprovider", createImageFile())
        photoURI = savePhotoInternalStorage(rotatedBitmap) //save photo rotated
        Log.d("EditP", "rotate: $photoURI")
        imgView.setImageBitmap(rotatedBitmap);
    }

    private fun rotateImage(currentPath : String, imgView : ImageView, bitmap : Bitmap) {
        var exifInterface : ExifInterface? = null;

        try {
            exifInterface = ExifInterface(currentPath)
        } catch (e: IOException) {
            e.printStackTrace();
        }

        val orientation : Int = exifInterface!!.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED)
        val matrix = Matrix()

        when (orientation) {
            ExifInterface.ORIENTATION_ROTATE_90 -> matrix.setRotate(90F)
            ExifInterface.ORIENTATION_ROTATE_180 ->  matrix.setRotate(180F)
            ExifInterface.ORIENTATION_ROTATE_270 ->  matrix.setRotate(270F)
            else ->  matrix.setRotate(0F)
        }
        val rotatedBitmap : Bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
        imgView.setImageBitmap(rotatedBitmap);

    }

    private fun UpdateAccountlayout (){
        emailEdit.setText(auth.currentUser?.email)

        nameEdit.visibility = View.GONE
        nicknameEdit.visibility = View.GONE
        locationEdit.visibility = View.GONE
        emailEdit.visibility = View.VISIBLE
        passwordEdit.visibility = View.VISIBLE
        changeAccount.visibility = View.GONE
        SavePassword.visibility = View.VISIBLE
    }


    //Change email and password
    private fun updateAccount(user: FirebaseUser) {
        if (!validateForm()) {
            return
        }

        val pass = passwordEdit.text.toString()
        user.updatePassword(pass)
            .addOnCompleteListener { task ->
                Log.d("EPUA", "User password updated.")
                if (task.isSuccessful) {
                    Log.d("EPUA", "User password updated.")
                }
            }.addOnFailureListener{
                Log.d("EPUA", "Uer password failed.")
            }

        nameEdit.visibility = View.VISIBLE
        nicknameEdit.visibility = View.VISIBLE
        locationEdit.visibility = View.VISIBLE
        emailEdit.visibility = View.GONE
        passwordEdit.visibility = View.GONE
        SavePassword.visibility = View.GONE

        //Return to normal
    }

    private fun validateForm(): Boolean {
        var valid = true

        /*val email = emailEdit.text.toString()
        if (TextUtils.isEmpty(email)) {
            emailEdit.error = "Email is required."
            valid = false
        } else {
            emailEdit.error = null
        }*/

        val password = passwordEdit.text.toString()
        if (TextUtils.isEmpty(password)) {
            passwordEdit.error = "Password is required."
            valid = false
        } else {
            passwordEdit.error = null
        }
        return valid
    }

    private fun savePreferences() {
        val user = Users("",nameEdit.text.toString(), nicknameEdit.text.toString(),emailEdit.text.toString(),locationEdit.text.toString(), photoTakenPath)  //User Data Class, for JSON Object
        val jsonString = Gson().toJson(user);

        val sharedPreferences: SharedPreferences = activity?.getSharedPreferences("SP_USER", Context.MODE_PRIVATE)?: return
        with (sharedPreferences.edit()) {
            putString("Profile", jsonString);
            commit()
        }
    }
}



