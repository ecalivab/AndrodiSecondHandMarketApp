package com.example.lab02_exploits.ui.itemEdit

import android.Manifest
import androidx.lifecycle.Observer
import android.annotation.SuppressLint
import android.app.Activity
import android.app.DatePickerDialog
import android.content.ContentValues.TAG
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Color
import android.graphics.Matrix
import android.graphics.drawable.BitmapDrawable
import android.media.ExifInterface
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.text.InputType
import android.text.TextUtils
import android.util.Log
import android.view.*
import android.widget.*
import androidx.activity.addCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.FileProvider
import androidx.core.graphics.drawable.RoundedBitmapDrawable
import androidx.core.graphics.drawable.RoundedBitmapDrawableFactory
import androidx.fragment.app.Fragment
import androidx.lifecycle.ViewModelProviders
import androidx.navigation.fragment.findNavController
import com.android.volley.Response
import com.android.volley.toolbox.JsonObjectRequest
import com.android.volley.toolbox.Volley
import com.bumptech.glide.Glide
import com.example.lab02_exploits.Items
import com.example.lab02_exploits.R
import com.google.android.gms.maps.model.MarkerOptions
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.GeoPoint
import com.google.firebase.messaging.FirebaseMessaging
import com.google.gson.GsonBuilder
import kotlinx.android.synthetic.main.fragment_edit_details.*
import kotlinx.android.synthetic.main.fragment_edit_profile.*
import org.json.JSONException
import org.json.JSONObject
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.OutputStream
import java.text.SimpleDateFormat
import java.util.*
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.LocalDate
import java.time.LocalTime
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.FormatStyle



class ItemEditFragment : Fragment() {

    private var rot = 0
    private var itemId :String = "0"
    private var  photoTakenPath : String = "";
    lateinit var spinner: Spinner
    lateinit var auth : FirebaseAuth
    private var photoURI: Uri? = null
    private var spinString: String = "Choose Category"
    private var mContext: Context? = null
    private var currentUser : String? = null
    private var interestUsersList : MutableList<String> = ArrayList()
    private val itemDB = FirebaseFirestore.getInstance().collection("Items")

    private var marker : MarkerOptions = MarkerOptions()
    private var location = ""
    private var geoItem : GeoPoint? = null


    override fun onAttach(context: Context) {
        super.onAttach(context)
        mContext = context
    }

    override fun onDetach() {
        super.onDetach()
        mContext = null
    }

    companion object {
        fun newInstance() =
            ItemEditFragment()
        //image pick code
        private val IMAGE_PICK_CODE = 1000;
        //Permission code
        private val PERMISSION_CODE = 1001;
        private const val FCM_API = "https://fcm.googleapis.com/fcm/send"
        private const val serverKey = "key=AAAA-o5B30c:APA91bFGHNeJd9_vwKUZFQAOfqLezk6nyJrqkoVC4dR4ZM9dZD-sHlG0FJYuJQ6jhPLNApD8o-gF9cFVF6XSLeCUIFcgnqZj5u7Q5AbEKQePkgsUnxopIcSvoS-tAMdGs0y4gEbg5l4b"
        private const val contentType = "application/json"
    }

    private lateinit var viewModel: ItemEditViewModel

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        setHasOptionsMenu(true)
        activity?.window?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);
        return inflater.inflate(R.layout.fragment_edit_details, container, false)
    }

    override fun onStart() {
        super.onStart()
        currentUser = auth.currentUser?.uid
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        //Receive data from itemDetails
        Log.d("WHYY", "OnViewCreated")
        Log.d("WHYY", "ItemID $itemId")
        if (null == savedInstanceState) {
            itemId = arguments?.getString("adapter_id", "0") ?: "0"
            interestUsersList = arguments?.getStringArrayList("adapter_userList") ?: mutableListOf()
            spinString = arguments?.getString("adapter_category", "Choose Category") ?: "Choose Category"

            marker = arguments?.getParcelable<MarkerOptions>("item_loc") ?: MarkerOptions()
            location = arguments?.getString("item_addr") ?: ""

            if(expirydateEditDetails.text.toString() == "")
            {
                val currentDateTime = LocalDateTime.now()
                expirydateEditDetails.setText(currentDateTime.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT)))
            }


            Log.d("positionEdit", "itemId $itemId")
            Log.d("positionEdit", "Lat ${marker.position?.latitude}")
            Log.d("positionEdit", "Long ${marker.position?.longitude}")

            arguments?.clear() //It needs to be clear otherwise it continues to add the last item
            //End receive data from item details
        } else {
            //Log.d("itemEditFragmentEntered", )
            spinString = savedInstanceState.getString("cat", "Choose Category")!!
            location = savedInstanceState.getString("loc", "Location")
            locationEditDetails.text = location
            Log.i(TAG, "SpinRecoveredValue() — get string: $spinString")
            photoTakenPath = savedInstanceState.getString("image") ?: ""
            if (!photoTakenPath.isEmpty()) {
                Glide.with(requireContext())
                    .load(photoTakenPath)
                    .into(itemphotoEditDetails)
            }
        }

        requireActivity().onBackPressedDispatcher.addCallback(this) {
            if(locationEditDetails.text.toString() == "Location") {
                findNavController().navigate(R.id.action_nav_itemEdit_to_nav_itemList)
            } else {
                Toast.makeText(requireContext(), "Please Save Before Going Back", Toast.LENGTH_LONG).show()
            }
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        if(photoTakenPath != "") {
            outState.putString("image", photoTakenPath)
        }
        if(spinString != "Choose Category")
        {
            outState.putString("cat", spinString)
            Log.i(TAG, "SpinValueOnSaveInsance() — get string: $spinString")
        }

        if(locationEditDetails?.text != null) {
            outState.putString("loc", locationEditDetails.text.toString())
        }

        super.onSaveInstanceState(outState)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewModel = ViewModelProviders.of(this).get(ItemEditViewModel::class.java)
        auth = FirebaseAuth.getInstance()

        locationEditDetails.setOnClickListener {
            if (ActivityCompat.checkSelfPermission(requireContext(), Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                    requireContext(), Manifest.permission.ACCESS_COARSE_LOCATION ) != PackageManager.PERMISSION_GRANTED) {
                val permissions = arrayOf(Manifest.permission.ACCESS_FINE_LOCATION)
                requestPermissions(permissions, 1520);
            } else {
                if(titleEditDetails?.text.isNullOrEmpty())
                    titleEditDetails.setText("")
                if (priceEditDetails?.text.isNullOrEmpty()) {
                    priceEditDetails.setText("0.0")
                }
                currentUser?.let { it1 ->
                    viewModel.updateItemBeforeMaps( itemId,
                        it1,titleEditDetails?.text.toString(), priceEditDetails?.text.toString().toDouble(),spinner.getItemAtPosition(0).toString(),
                        expirydateEditDetails?.text.toString(), descriptionEditDetails?.text.toString(),photoTakenPath)
                }

                val bundle = Bundle()
                bundle.putString("adapter_id", itemId)
                bundle.putString("adapter_category", spinString)
                bundle.putStringArrayList("adapter_userList", interestUsersList as ArrayList<String>)
                findNavController().navigate(R.id.action_nav_itemEdit_to_nav_map_item, bundle)
            }
        }
        Log.d("WHYY", "ItemID $itemId")
        if(itemId !="0") {
            observeCurrentItem(itemId)
        }

        if(itemId == "0") {
            val itemRef = itemDB.document()
            itemId = itemRef.id
        }

        val imgMenu : ImageButton? = activity?.findViewById(R.id.itemphotoEditDetails);
        if (imgMenu != null) {
            registerForContextMenu(imgMenu)
        }

        //Handle Date Picker EditText
        val dpBtn : EditText? = activity?.findViewById(R.id.expirydateEditDetails)
        dpBtn?.inputType = InputType.TYPE_NULL;
        dpBtn?.setTextIsSelectable(false);
        val c = Calendar.getInstance()
        val year = c.get(Calendar.YEAR)
        val month = c.get(Calendar.MONTH)
        val day = c.get(Calendar.DAY_OF_MONTH)

        dpBtn?.setOnClickListener {

            val dpd =
                mContext?.let { it1 ->
                    DatePickerDialog(it1, DatePickerDialog.OnDateSetListener { view, year, month, day ->
                        // Display Selected date in TextView
                        dpBtn.setText("" + day + "/" + (month+1) + "/" + year)
                    }, year, month, day)
                }
            dpd?.show()
        }


        //End handle Date Picker Button

        //Handle Spinner
        val categories = arrayOf(spinString, "Arts & Crafts", "Sports & Hobby", "Baby", "Women's fashion", "Men's fashion", "Electronics", "Games & Videogames", "Automotive")
        val adapter: ArrayAdapter<String>? = mContext?.let { ArrayAdapter<String>(it, android.R.layout.simple_spinner_item, categories) }
        adapter?.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        spinner = activity?.findViewById(R.id.categoryEditDetails) as Spinner
        spinner.adapter = adapter

        spinner.setOnItemSelectedListener(object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(adapterView: AdapterView<*>, view: View?, position: Int, id: Long) {
                val itm = adapterView.getItemAtPosition(position)
                if (itm != null) {
                    if (view != null) {
                        showPopup(view, (position-1))
                    }
                    //Toast.makeText(mContext, itm.toString(), Toast.LENGTH_SHORT).show()
                }
                //Toast.makeText(mContext, "Selected", Toast.LENGTH_SHORT).show()
            }

            override fun onNothingSelected(adapterView: AdapterView<*>?) {
            }
        })
        //End handle spinner
    }

    private fun observeCurrentItem (iId : String) {
        viewModel.fetchItem(iId).observe(viewLifecycleOwner, Observer {
            priceEditDetails.setText(it?.price.toString())
            spinString = it?.category.toString()
            expirydateEditDetails.setText(it?.expireDate)
            titleEditDetails.setText(it?.title)
            locationEditDetails.text = it?.location
            descriptionEditDetails.setText(it?.description)

            geoItem = it?.geoPoint

            photoTakenPath = it?.itemURI.toString()
            if (!it.itemURI.isNullOrEmpty()) {
                Glide.with(requireContext())
                    .load(it.itemURI)
                    .into(itemphotoEditDetails)
            }
        })
    }


    private fun sendNotificationToSubscribers(titleNotification : String, message : String) {

        val notification = JSONObject()
        val notificationBody = JSONObject()

        try {
            notificationBody.put("title", titleNotification)
            notificationBody.put("text", message)   //Enter your notification message
            notification.put("to", "/topics/$itemId")
            notification.put("notification", notificationBody)
            Log.e("TAG", "try")
        } catch (e: JSONException) {
            Log.e("TAG", "onCreate: " + e.message)
        }
        Log.d("TAG", "Notification: $notification")
        sendNotification(notification)
    }

    private fun sendNotification(notification: JSONObject) {
        Log.e("TAG", "sendNotification")
        val jsonObjectRequest = object : JsonObjectRequest(FCM_API, notification,
            Response.Listener<JSONObject> { response ->
                Log.i("TAG", "onResponse: $response")
            },
            Response.ErrorListener {
                Toast.makeText(requireContext(), "Request error", Toast.LENGTH_LONG).show()
                Log.i("TAG", "onErrorResponse: Didn't work")
            }) {

            override fun getHeaders(): Map<String, String> {
                val params = HashMap<String, String>()
                params["Authorization"] = serverKey
                params["Content-Type"] = contentType
                return params
            }
        }
        val requestQueue = Volley.newRequestQueue(requireContext())
        requestQueue.add(jsonObjectRequest)
    }

    //Handle Subcategory menu
    private fun showPopup(view: View, categoryNumber: Int) {
        val subcategory0 : Array<String> = arrayOf("Painting, Drawing & Art Supplies", "Sewing", "Scrapbooking & Stamping", "Party Decorations & Supplies")
        val subcategory1 : Array<String> = arrayOf("Sports and Outdoors", "Outdoor Recreation", "Sports & Fitness", "Pet Supplies")
        val subcategory2 : Array<String> = arrayOf("Apparel & Accessories", "Baby & Toddler Toys", "Car Seats & Accessories", "Pregnancy & Maternity", "Strollers & Accessories")
        val subcategory3 : Array<String> = arrayOf("Woman Clothing", "Woman Shoes", "Woman Watches", "Woman Handbags", "Woman Accessories")
        val subcategory4 : Array<String> = arrayOf("Man Clothing", "Man Shoes", "Man Watches", "Man Accessories")
        val subcategory5 : Array<String> = arrayOf("Computers", "Monitors", "Printers & Scanners", "Camera & Photo", " Smartphone & Tablet", "Audio", "Television & Video", "Video Game Consoles", "Wearable Technology", "Accessories & Supplies", "Irons & Steamers", "Vacuums & Floor Care")
        val subcategory6 : Array<String> = arrayOf("Action Figures & Statues", "Arts & Crafts", "Building Toys", "Dolls & Accessories", "Kids' Electronics", "Learning & Education", "Tricycles, Scooters & Wagons", " Videogames")
        val subcategory7 : Array<String> = arrayOf("Car Electronics & Accessories", "Car & Moto Accessories", "Motorcycle & Powersports", "Replacement Parts", " RV Parts & Accessories", "Tools & Equipment")
        var popup: PopupMenu? = null;
        popup = PopupMenu(mContext, view)
        when(categoryNumber) {
            0 -> for (str in subcategory0){ popup.menu.add(str)}
            1 -> for (str in subcategory1){ popup.menu.add(str)}
            2 -> for (str in subcategory2){ popup.menu.add(str)}
            3 -> for (str in subcategory3){ popup.menu.add(str)}
            4 -> for (str in subcategory4){ popup.menu.add(str)}
            5 -> for (str in subcategory5){ popup.menu.add(str)}
            6 -> for (str in subcategory6){ popup.menu.add(str)}
            7 -> for (str in subcategory7){ popup.menu.add(str)}
            else -> println("Error")
        }
        popup.inflate(R.menu.subcategory_menu)
        popup.setOnMenuItemClickListener(PopupMenu.OnMenuItemClickListener { item: MenuItem? ->
            spinString = item.toString()
            val categories = arrayOf(item.toString(), "Arts & Crafts", "Sports & Hobby", "Baby", "Women's fashion", "Men's fashion", "Electronics", "Games & Videogames", "Automotive")
            val adapter: ArrayAdapter<String>? = mContext?.let { ArrayAdapter<String>(it, android.R.layout.simple_spinner_item, categories) }
            adapter?.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            spinner = activity?.findViewById(R.id.categoryEditDetails) as Spinner
            spinner.adapter = adapter
            true
        })
        popup.show()
    }
    //End handle subcategory menu

    //GESTIONE SAVE MENU
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.save_item_menu, menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.saveItem -> {
                Log.d("EditItem", "SAVE")
                if(TextUtils.isEmpty(titleEditDetails.text)){
                    titleEditDetails.error = "Title is required"
                    return false
                } else if(categoryEditDetails.getSelectedItem().toString() == "Choose Category"){
                    val errorText: TextView = categoryEditDetails.getSelectedView() as TextView
                    errorText.error = "Category is required";
                    errorText.setTextColor(Color.RED);//just to highlight that this is an error
                    errorText.text = "Category is required";//changes the selected item text to this
                    return false
                }else if(TextUtils.isEmpty(locationEditDetails.text)) {
                    locationEditDetails.error = ("Location is required")
                    return false
                }
                else if(TextUtils.isEmpty(priceEditDetails.text) || priceEditDetails.text.toString() == "0.0" || priceEditDetails.text.toString() == "0")
                {
                    priceEditDetails.error = ("Price is required")
                    return false
                }  else if (TextUtils.isEmpty(expirydateEditDetails.text) || expirydateEditDetails.text.toString() == "Insert Date") {
                    expirydateEditDetails.error = ("Expiration Date is required")
                    return false
                }
                Log.d("EditItem", "END OF SAVE")
                saveUpdateItem();
                //findNavController().navigate(R.id.action_nav_itemEdit_to_nav_itemList)
                true
            }
            android.R.id.home ->{
               if(locationEditDetails.text.toString() == "Location") {
                   Log.d("MAPERCHE", "ENTRE IF")
                    findNavController().navigate(R.id.action_nav_itemEdit_to_nav_itemList)
                    return false
                } else {
                   Log.d("MAPERCHE", "ENTRE ELSE")
                    Toast.makeText(requireContext(), "Please Save the Item Before Going Back", Toast.LENGTH_LONG).show()
                   return true
               }
            }

            R.id.deleteM -> {
                Log.d("KKA","delete itemId: $itemId")
                if(itemId != "0")
                    deleteItem();
                //findNavController().navigate(R.id.action_nav_itemEdit_to_nav_itemList)
                true
            }
            R.id.blockM -> {
                if(TextUtils.isEmpty(titleEditDetails.text)){
                    titleEditDetails.error = "Title is required"
                    return false
                }
                saveUpdateItem("1");
                sendNotificationToSubscribers("Item Block", "The seller has block this item: ${titleEditDetails.text}")
                //findNavController().navigate(R.id.action_nav_itemEdit_to_nav_itemList)
                true
            }

            else -> super.onOptionsItemSelected(item)
        }
    }
    //FINE GESTIONE SAVE MENU

    //DA QUI GESTIONE MENU PHOTO
    override fun onCreateContextMenu(menu: ContextMenu, v: View, menuInfo: ContextMenu.ContextMenuInfo?) {
        super.onCreateContextMenu(menu, v, menuInfo)
        menu.setHeaderTitle("Choose an Option")
        val inflater : MenuInflater? = activity?.menuInflater
        inflater?.inflate(R.menu.photo_menu, menu)
    }
    
    override fun onContextItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.gallery -> {
                pickImageFromGallery();
                Toast.makeText(activity?.applicationContext, "Gallery", Toast.LENGTH_SHORT).show()
                true
            }
            R.id.camera -> {
                dispatchTakePictureIntent();
                Toast.makeText(activity?.applicationContext, "Camera", Toast.LENGTH_SHORT).show()
                true
            }
            R.id.rotate -> {
                Log.d("qqq", "photoTakenPath: $photoTakenPath")
                if(photoTakenPath.isEmpty()) {
                    Toast.makeText(requireContext(), "There is not an image", Toast.LENGTH_SHORT).show()
                    return true
                }
                if(photoTakenPath.startsWith("http")){
                    val bitmap = (itemphotoEditDetails.drawable as BitmapDrawable).bitmap
                    savePhotoInternalStorage(bitmap, true)
                }
                Log.d("asd", "photoTakenPath: $photoTakenPath")
                rotate(itemphotoEditDetails, setReducedImageSize(photoTakenPath, itemphotoEditDetails))
                Toast.makeText(activity?.applicationContext, "Rotate", Toast.LENGTH_SHORT).show()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }
    //FINE GESTIONE MENU PHOTO

    //SALVATAGGIO NEI SAVE PREFERENCES DELL'ITEM
    private fun savePreferences() {
        //SALVATAGGIO DELL'ITEM NELLA MEMORIA INTERNA
        val gsonPretty = GsonBuilder().setPrettyPrinting().create()
        val jsonString = gsonPretty.toJson(Items.itemList);

        Log.d("KKA", "JSON Save Preferences $jsonString")

        val sharedPreferences: SharedPreferences = activity?.getSharedPreferences("SP_ITEM_LIST", Context.MODE_PRIVATE)?: return
        with (sharedPreferences.edit()) {
            putString("Items", jsonString);
            commit()
        }
    }

    private fun saveUpdateItem(status : String = "0") {
        spinner = activity?.findViewById(R.id.categoryEditDetails) as Spinner

        if(currentUser == null) {
            Toast.makeText(requireContext(), "You need to Sign In to Add an Item", Toast.LENGTH_SHORT).show()
        }

        if(itemId == "0" && currentUser != null) {
            Log.d("ItemEdit", "NEW ITEM")
            val itemObj = Items(currentUser, itemId,  titleEditDetails.text.toString(), descriptionEditDetails.text.toString(), priceEditDetails.text.toString().toDouble(),  spinner.getItemAtPosition(0).toString(), locationEditDetails.text.toString(),
                expirydateEditDetails.text.toString(), mutableListOf(), photoTakenPath, status, geoItem)
            FirebaseMessaging.getInstance().subscribeToTopic(itemId)
            viewModel.addItem(itemId, itemObj,photoURI, findNavController()) //Pass Navigation Controller to Asynchronous behavior
        } else {
            if (itemId != "0" && currentUser != null) {
                Log.d("ItemEdit", "UPDATE")
                val itemObj = Items(currentUser, itemId, titleEditDetails.text.toString(), descriptionEditDetails.text.toString(), priceEditDetails.text.toString().toDouble(), spinner.getItemAtPosition(0).toString(), locationEditDetails.text.toString(),
                    expirydateEditDetails.text.toString(), interestUsersList, photoTakenPath, status, geoItem)
                FirebaseMessaging.getInstance().subscribeToTopic(itemId)
               viewModel.updateItem(itemId, itemObj, photoURI, findNavController())
            }
        }
    }

    private fun deleteItem() {
        if(itemId != "0" && currentUser != null)
            viewModel.deleteItem(itemId, findNavController())
    }

    //PRESA E SALVATAGGIO FOTO
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_TAKE_PHOTO && resultCode == AppCompatActivity.RESULT_OK) {
            //val imageBitmap = data?.extras?.get(currentPhotoPath) as Bitmap
            //BitmapFactory.decodeFile(currentPhotoPath)?.also { imageBitmap ->
            // photoEdit.setImageBitmap(imageBitmap)
            //}
            //rotateImage(photoTakenPath.toString(), itemphotoEditDetails , setReducedImageSize(photoTakenPath, itemphotoEditDetails));
            Glide.with(requireContext())
                .load(photoTakenPath)
                .into(itemphotoEditDetails)
        }

        if (resultCode == Activity.RESULT_OK && requestCode == ItemEditFragment.IMAGE_PICK_CODE) {
            itemphotoEditDetails.setImageURI(data?.data)
            photoURI = data?.data!!
            val bitmap = (itemphotoEditDetails.drawable as BitmapDrawable).bitmap
            savePhotoInternalStorage(bitmap, true)
        }
    }

    //photoTakenPath is hardcoded maybe is better to change as a function parameter (future work)
    private fun savePhotoInternalStorage(photo: Bitmap, flag: Boolean = false) :Uri {
        val dir= activity?.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
        Log.d("KKK", "FLAG $flag")

        val file = if (flag) {
            File(dir, "${UUID.randomUUID()}.jpg")
        } else {
            File(photoTakenPath)
        }

        try {
            // Get the file output stream
            val stream: OutputStream = FileOutputStream(file)
            // Compress bitmap
            photo.compress(Bitmap.CompressFormat.JPEG, 100, stream)
            // Flush the stream
            stream.flush()
            // Close stream
            stream.close()
        } catch (e: IOException) { // Catch the exception
            e.printStackTrace()
        }
        photoTakenPath=file.absolutePath
        return Uri.fromFile(file)
        //return  file.absolutePath
    }

    private fun pickImageFromGallery (){
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if(activity?.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_DENIED) {
                val permissions = arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE);
                //show popup to request runtime permission
                requestPermissions(permissions, PERMISSION_CODE);

            } else {
                val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
                intent.type = "image/*"
                startActivityForResult(intent, IMAGE_PICK_CODE)
            }
        }
        else {
            //system OS is < Marshmallow
            val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
            intent.type = "image/*"
            startActivityForResult(intent, IMAGE_PICK_CODE)
        }
    }

    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        when(requestCode){
            PERMISSION_CODE -> {
                if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED){
                    //permission from popup granted
                    pickImageFromGallery()
                }
                else{
                    //permission from popup denied
                    Toast.makeText(activity, "Permission denied", Toast.LENGTH_SHORT).show()
                }
            }

            1520 -> {
                if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED){
                    //permission from popup granted
                    val bundle = Bundle()
                    bundle.putString("adapter_id", itemId)
                    bundle.putStringArrayList("adapter_userList", interestUsersList as ArrayList<String>)
                    findNavController().navigate(R.id.action_nav_itemEdit_to_nav_map_item, bundle)
                }
                else{
                    //permission from popup denied
                    Toast.makeText(activity, "Permission denied", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    //CAMERA
    lateinit var currentPhotoPath: String

    @SuppressLint("SimpleDateFormat")
    @Throws(IOException::class)
    private fun createImageFile(): File {
        // Create an image file name
        val timeStamp: String = SimpleDateFormat("yyyyMMdd_HHmmss").format(Date())
        val storageDir: File? = activity?.getExternalFilesDir(Environment.DIRECTORY_PICTURES)
        return File.createTempFile("JPEG_${timeStamp}_", ".jpg", storageDir).apply {
            // Save a file: path for use with ACTION_VIEW intents
            currentPhotoPath = absolutePath
            photoTakenPath = currentPhotoPath
        }
    }

    val REQUEST_TAKE_PHOTO = 1

    private fun dispatchTakePictureIntent() {
        Intent(MediaStore.ACTION_IMAGE_CAPTURE).also { takePictureIntent ->
            // Ensure that there's a camera activity to handle the intent
            activity?.packageManager?.let { it ->
                takePictureIntent.resolveActivity(it)?.also {
                    // Create the File where the photo should go
                    val photoFile: File? = try {
                        createImageFile()
                    } catch (ex: IOException) {
                        // Error occurred while creating the File
                        null
                    }
                    // Continue only if the File was successfully created
                    photoFile?.also {
                        photoURI= FileProvider.getUriForFile(requireContext(), "com.example.android.fileprovider", it)
                        takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI)
                        startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO)
                    }
                }
            }
        }
    }

    //ROTATE IMAGE
    private fun setReducedImageSize(currentPath : String?, imgView : ImageView) : Bitmap {
        val targetImageViewWidth: Int = itemphotoEditDetails.width
        val targetImageViewHeight: Int = itemphotoEditDetails.height

        val bmOptions = BitmapFactory.Options().apply {
            inJustDecodeBounds = true
        }

        BitmapFactory.decodeFile(currentPath, bmOptions)
        val cameraImageWidth =  bmOptions.outWidth
        val cameraImageHeight = bmOptions.outHeight

        val scaleFactor = Math.min(cameraImageWidth/targetImageViewWidth, cameraImageHeight/targetImageViewHeight);
        bmOptions.inSampleSize = scaleFactor;
        bmOptions.inJustDecodeBounds = false;

        //var photoReducedSizeBitmp : Bitmap = BitmapFactory.decodeFile(currentPath,bmOptions);
        //imgView.setImageBitmap(photoReducedSizeBitmp);
        return BitmapFactory.decodeFile(currentPath,bmOptions);
    }

    private fun rotate(imgView : ImageView, bitmap : Bitmap) {
        val matrix = Matrix()
        rot += 90
        if(rot >= 360)
        {
            rot = 0
        }
        matrix.setRotate(rot.toFloat())
        val rotatedBitmap : Bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
        photoURI = savePhotoInternalStorage(rotatedBitmap) //save photo rotated
        imgView.setImageBitmap(rotatedBitmap);
    }

    private fun rotateImage(currentPath : String, imgView : ImageView, bitmap : Bitmap) {
        var exifInterface : ExifInterface? = null;

        try {
            exifInterface = ExifInterface(currentPath)
        } catch (e: IOException) {
            e.printStackTrace();
        }

        val orientation : Int = exifInterface!!.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED)
        val matrix = Matrix()

        when (orientation) {
            ExifInterface.ORIENTATION_ROTATE_90 -> matrix.setRotate(90F)
            ExifInterface.ORIENTATION_ROTATE_180 ->  matrix.setRotate(180F)
            ExifInterface.ORIENTATION_ROTATE_270 ->  matrix.setRotate(270F)
            else ->  matrix.setRotate(0F)
        }
        val rotatedBitmap : Bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
        imgView.setImageBitmap(rotatedBitmap);

    }
    //FINE PRENDI E SALVA FOTO

    //PASSAGGIO DATI AL FRAGMENTO nav_itemList
    private fun returnValuesNav() {
        val bundle = Bundle()
        bundle.putString("adapter_id", itemId)
        bundle.putString("adapter_title", titleEditDetails.text.toString())
        bundle.putString("adapter_description", descriptionEditDetails.text.toString())
        bundle.putString("adapter_price", priceEditDetails.text.toString())
        spinner = activity?.findViewById(R.id.categoryEditDetails) as Spinner
        bundle.putString("adapter_category", spinner.getItemAtPosition(0).toString())
        bundle.putString("adapter_expireDate", expirydateEditDetails.text.toString())
        bundle.putString("adapter_location", locationEditDetails.text.toString())
        bundle.putString("adapter_exprireDate", expirydateEditDetails.text.toString())
        bundle.putString("adapter_itemURI", photoTakenPath)

        findNavController().navigate(R.id.action_nav_itemEdit_to_nav_itemList, bundle)

    }
    //FINE PASSAGGIO DATI AL FRAMENTO nav:showProfile
}


