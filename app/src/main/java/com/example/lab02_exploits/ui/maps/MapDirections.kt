package com.example.lab02_exploits.ui.maps

import android.graphics.Color
import android.os.Bundle
import android.util.Log
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.activity.addCallback
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import com.android.volley.Request
import com.android.volley.Response
import com.android.volley.toolbox.StringRequest
import com.android.volley.toolbox.Volley
import com.example.lab02_exploits.R
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.OnMapReadyCallback
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.MarkerOptions
import com.google.android.gms.maps.model.PolylineOptions
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.GeoPoint
import com.google.maps.android.PolyUtil
import kotlinx.android.synthetic.main.fragment_maps.*
import org.json.JSONObject

class MapDirections : Fragment() , OnMapReadyCallback {

    private lateinit var viewModel: MapViewModel
    private lateinit var auth: FirebaseAuth
    private var geoUser: GeoPoint? = null
    private var geoItem: GeoPoint? = null
    private var currentUser = ""
    private var itemId = ""
    private var urlDirections = ""

    private lateinit var mMap : GoogleMap
    private var mapReady = false

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.fragment_map_directions, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val latitude = arguments?.getDouble("geoItemLatitude", 0.0) ?: 0.0
        val longitude = arguments?.getDouble("geoItemLongitude", 0.0) ?: 0.0

        geoItem = GeoPoint(latitude,longitude)
        Log.d("position", "$geoItem")
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewModel = ViewModelProviders.of(this).get(MapViewModel::class.java)

        auth = FirebaseAuth.getInstance()
        currentUser = auth.currentUser?.uid.toString()

        map_view.onCreate(savedInstanceState)
        map_view.onResume()
        map_view.getMapAsync(this)

        Log.d("position", "itemId: $itemId")
        observeGeoPoints(currentUser, itemId)


        requireActivity().onBackPressedDispatcher.addCallback(this) {
            Toast.makeText(requireContext(), "Use the Navigation Drawer Back Button", Toast.LENGTH_SHORT).show()
        }
    }


    //Toast.makeText(requireContext(), "Back press disabled!", Toast.LENGTH_SHORT).show();

    private fun observeGeoPoints(uId : String, iId :String) {
            viewModel.fetchUserLocation(uId).observe(viewLifecycleOwner, Observer {
                    userLoc ->
                        geoUser = userLoc
                        Log.d("position", "Observer")
                        Log.d("position", "$geoUser")
                        Log.d("position", "$geoItem")
                        if(geoUser != null && geoItem !=null) {
                            Log.d("position", "Entre")
                            updateMap(geoUser!!, geoItem!!)
                        }
            })
    }


    private fun updateMap(origin: GeoPoint, destination: GeoPoint) {
        Log.d("position", "Entre updateMap")
        if (mapReady) {
            Log.d("position", "MapMarker")
            mMap.addMarker(MarkerOptions().position(LatLng(origin.latitude, origin.longitude)))
            mMap.addMarker(MarkerOptions().position(LatLng(destination.latitude, destination.longitude)))
            mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(geoUser?.latitude!!, geoUser?.longitude!!), 8F));

            mMap.addPolyline(
                PolylineOptions().add(
                    LatLng(origin.latitude, origin.longitude),
                    LatLng(destination.latitude, destination.longitude)
                ).width(2F).color(Color.BLUE).geodesic(true)
            )
            //getURL(LatLng(origin.latitude, origin.longitude),LatLng(destination.latitude, destination.longitude))
            //directions()
        }
    }

    private fun getURL(from : LatLng, to : LatLng) {
        val origin = "origin=" + from.latitude + "," + from.longitude
        val dest = "destination=" + to.latitude + "," + to.longitude
        val sensor = "sensor=false"
        val params = "$origin&$dest&$sensor"
        urlDirections = "https://maps.googleapis.com/maps/api/directions/json?$params&key=AIzaSyAzyJhLya3sePWNeUr9htLFLB-G4a0Bq1k"
    }

    private fun directions() {
        val path: MutableList<List<LatLng>> = ArrayList()
        //val urlDirections = "https://maps.googleapis.com/maps/api/directions/json?origin=10.3181466,123.9029382&destination=10.311795,123.915864&key=<YOUR_API_KEY>"
        val directionsRequest = object : StringRequest(Request.Method.GET, urlDirections, Response.Listener<String> {
                response ->
            val jsonResponse = JSONObject(response)
            if(jsonResponse.toString().contains("error_message")) {
                Toast.makeText(requireContext(), "Error getting Direction", Toast.LENGTH_LONG).show()
                Log.d("position", "JSON: $jsonResponse")
            } else {
                Log.d("position", "JSON: $jsonResponse")
                // Get routes
                val routes = jsonResponse.getJSONArray("routes")
                val legs = routes.getJSONObject(0).getJSONArray("legs")
                val steps = legs.getJSONObject(0).getJSONArray("steps")
                for (i in 0 until steps.length()) {
                    val points = steps.getJSONObject(i).getJSONObject("polyline").getString("points")
                    path.add(PolyUtil.decode(points))
                }
                for (i in 0 until path.size) {
                    mMap.addPolyline(PolylineOptions().addAll(path[i]).color(Color.RED))
                }
            }}, Response.ErrorListener {
                    _ ->
            }){}
            val requestQueue = Volley.newRequestQueue(requireContext())
            requestQueue.add(directionsRequest)
    }

    override fun onMapReady(googleMap : GoogleMap?) {
        Log.d("position", "Entre a MapReady")
        googleMap?.let { map ->
            mMap = map
            mapReady = true
            //updateMap()
        }
    }
}






